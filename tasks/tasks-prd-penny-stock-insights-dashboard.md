## Relevant Files

- `app/dashboard/page.tsx` - Main dashboard component that displays the penny stock insights
- `app/dashboard/page.test.tsx` - Unit tests for the dashboard component
- `app/stocks/[symbol]/page.tsx` - Stock detail page component
- `components/StockList.tsx` - Component for displaying the filtered list of stocks
- `components/StockList.test.tsx` - Unit tests for the stock list component
- `components/StockCard.tsx` - Individual stock card component showing key metrics (with data-testid attributes)
- `components/StockCard.test.tsx` - Unit tests for the stock card component
- `components/StockDetail.tsx` - Detailed stock view component (with data-testid attributes)
- `components/StockFilters.tsx` - Stock filtering component
- `components/SparklineChart.tsx` - Price chart component (with data-testid attributes)
- `components/DataRefreshIndicator.tsx` - Data refresh status component (with data-testid attributes)
- `components/ErrorBoundary.tsx` - Error handling component (with data-testid attributes)
- `components/ui/loading.tsx` - Loading states component (with data-testid attributes)
- `lib/api/stockData.ts` - API integration layer for fetching stock data
- `lib/api/stockData.test.ts` - Unit tests for stock data API
- `lib/api/stockData.integration.test.ts` - Integration tests for stock data API with real Polygon.io calls
- `lib/utils/squeezeScore.ts` - Utility functions for calculating squeeze signal scores
- `lib/utils/squeezeScore.test.ts` - Unit tests for squeeze score calculations
- `lib/types/stock.ts` - TypeScript interfaces for stock data
- `lib/hooks/useStockFilters.ts` - Custom hook for managing stock filters
- `lib/hooks/useStockFilters.test.ts` - Unit tests for stock filters hook
- `cypress/e2e/dashboard.cy.ts` - E2E tests for dashboard critical user flows
- `cypress/e2e/stock-detail.cy.ts` - E2E tests for stock detail page critical user flows
- `cypress/e2e/example.cy.ts` - Example Cypress E2E test for the home page
- `cypress.config.ts` - Cypress configuration for E2E testing
- `components.json` - shadcn/ui registry and configuration file
- `src/lib/utils.ts` - Utility functions generated by shadcn/ui initialization
- `.prettierrc` - Prettier configuration file for code formatting
- `.prettierignore` - Ignore file for Prettier formatting
- `jest.config.js` - Jest configuration for Next.js and TypeScript
- `src/app/page.test.tsx` - Example test for the main page using React Testing Library
- `src/app/providers.tsx` - TanStack Query provider for data fetching
- `src/lib/store.ts` - Zustand store for global state management
- `src/lib/kv.ts` - Vercel KV client utility for caching
- `.env.example` - Example environment variables file
- `README.md` - Project documentation including setup and features
- `CONTRIBUTING.md` - Guidelines for project contributors
- `LICENSE` - MIT license file
- `.husky/pre-commit` - Husky pre-commit hook for running lint-staged
- `sentry.client.config.ts` - Sentry client configuration
- `sentry.server.config.ts` - Sentry server configuration
- `vercel.json` - Vercel deployment configuration
- `.github/workflows/ci.yml` - GitHub Actions CI workflow

### Notes

- Unit tests should be placed alongside their corresponding components and utilities
- Use `npx jest` to run all tests or `npx jest [file-path]` for specific tests
- API integration should use environment variables for API keys
- Consider implementing error boundaries for API failures
- Follow mobile-first design principles throughout

## Tasks

- [x] 0.0 Project Setup and Scaffolding

  - [x] 0.1 Initialize Next.js 14 project with TypeScript
  - [x] 0.2 Set up Tailwind CSS and shadcn/ui
  - [x] 0.3 Configure ESLint and Prettier
  - [x] 0.4 Set up Jest and React Testing Library
  - [x] 0.5 Configure Cypress for E2E testing
  - [x] 0.6 Set up TanStack Query and Zustand
  - [x] 0.7 Configure Vercel KV for caching
  - [x] 0.8 Set up environment variables and secrets
  - [x] 0.9 Configure Husky for pre-commit hooks
  - [x] 0.10 Set up Sentry for error tracking
  - [x] 0.11 Create initial project documentation
  - [x] 0.12 Configure CI/CD pipeline with Vercel

- [x] 1.0 Data Integration and API Setup

  - [x] 1.1 Set up Yahoo Finance/Polygon.io API integration
  - [x] 1.2 Implement API key management using environment variables
  - [x] 1.3 Create TypeScript interfaces for stock data types
  - [x] 1.4 Implement error handling and retry logic for API calls
  - [x] 1.5 Set up API rate limiting and request throttling
  - [x] 1.6 Create mock data for development and testing

- [x] 2.0 Core Dashboard UI Implementation

  - [x] 2.1 Create responsive dashboard layout with mobile-first approach
  - [x] 2.2 Implement stock list component with virtual scrolling
  - [x] 2.3 Create stock card component with key metrics display
  - [x] 2.4 Add sparkline charts for 30-day price visualization
  - [x] 2.5 Implement stock detail view with expanded metrics
  - [x] 2.6 Add loading states and error boundaries
  - [x] 2.7 Create detailed stock analysis view

- [x] 3.0 Stock Filtering System

  - [x] 3.1 Implement basic stock universe filtering ($1-$5 price, $20M-$300M market cap)
  - [x] 3.2 Create filter UI components for volume spike threshold
  - [x] 3.3 Add short interest percentage filtering
  - [x] 3.4 Implement sector/industry filtering
  - [x] 3.5 Add dilution risk level filtering
  - [x] 3.6 Create custom hook for managing filter state
  - [x] 3.7 Implement filter persistence

- [x] 4.0 Squeeze Signal Score Implementation

  - [x] 4.1 Create algorithm for volume vs average volume comparison
  - [x] 4.2 Implement short interest percentage calculation
  - [x] 4.3 Add trading flow metrics analysis
  - [x] 4.4 Integrate SEC filing presence check
  - [x] 4.5 Implement news report presence detection
  - [x] 4.6 Add social media buzz metrics calculation
  - [x] 4.7 Create weighted scoring system (0-100)

- [x] 5.0 Data Management and Caching

  - [x] 5.1. Create daily update utility
    - [x] Implement daily data refresh
    - [x] Add update scheduling
    - [x] Create update logging
  - [x] 5.2. Set up data caching system
    - [x] Implement cache for stock data
    - [x] Add cache invalidation
    - [x] Set up cache monitoring
  - [x] 5.3. Create historical data storage
    - [x] Implement 30-day data retention
    - [x] Add data cleanup utility
    - [x] Set up data archiving
  - [x] 5.4. Implement data validation
    - [x] Add input validation
    - [x] Create data sanitization
    - [x] Implement error handling
  - [x] 5.5. Add data refresh indicators
    - [x] Create refresh status component
    - [x] Add last update timestamps
    - [x] Implement refresh notifications
  - [x] 5.6. Create data backup mechanism
    - [x] Implement automatic backups
    - [x] Add backup restoration
    - [x] Set up backup cleanup

- [x] 6.0 Performance Optimization and Testing

  - [x] 6.1 Write unit tests for all components
  - [x] 6.2 Implement integration tests for API calls
  - [x] 6.3 Add end-to-end tests for critical user flows
  - [x] 6.4 Optimize bundle size and loading performance
    - Enabled @next/bundle-analyzer to inspect the production bundle and identify large dependencies.
    - Identified recharts (used in SparklineChart) as a significant contributor to bundle size.
    - Refactored StockCard and StockDetail components to dynamically import SparklineChart using next/dynamic (ssr: false), enabling code splitting and reducing the main bundle size.
    - Documented the optimization steps in the README.
  - [x] 6.5 Implement code splitting and lazy loading

    - Implemented dynamic imports for heavy components to reduce initial bundle size:
      - StockDetail - Lazy loaded in stock detail page with loading fallback
      - StockFilters - Lazy loaded in dashboard with skeleton loading state
      - DataRefreshIndicator - Lazy loaded in StockList component
      - ErrorMessage - Lazy loaded in both stock detail and list components
    - Bundle size improvements achieved:
      - Dashboard page: 37.5 kB → 17.3 kB (53.9% reduction)
      - Stock detail page: 3.13 kB → 1.38 kB (55.9% reduction)
      - Total First Load JS for dashboard: 130 kB → 109 kB (16.2% reduction)
    - All lazy-loaded components use ssr: false to ensure proper client-side rendering
    - Documented optimizations in README.md

  - [x] 6.6 Add performance monitoring

    - Enhanced Sentry integration with comprehensive performance monitoring:
      - Browser tracing and session replay with adaptive sampling (10% production, 100% development)
      - Environment-specific configuration and release tracking
    - Implemented Core Web Vitals tracking:
      - Real-time monitoring of LCP, FID, CLS with automatic threshold alerts
      - Page load performance tracking (TTFB, FCP)
    - Created custom performance monitoring system:
      - Component render time tracking with performance hooks
      - API call duration monitoring with slow call detection
      - User interaction and route change performance tracking
    - Built development tools:
      - Real-time performance monitor dashboard (development only)
      - Performance measurement utilities and hooks
      - Console logging for performance metrics
    - Created performance monitoring hooks:
      - usePerformanceTracking() - Track component render times
      - usePagePerformance() - Monitor page load performance
      - useChartPerformance() - Track chart rendering performance
      - useFilterPerformance() - Monitor filter application performance
    - Integrated performance monitoring into dashboard and stock detail pages
    - Documented performance monitoring features in README.md

  - [x] 6.7 Create documentation for testing procedures

    - Created comprehensive testing documentation:
      - docs/testing-procedures.md - Complete testing strategy, best practices, and procedures
      - docs/testing-quick-reference.md - Quick commands and common patterns
    - Documented testing strategy covering:
      - Unit testing with Jest + React Testing Library
      - Integration testing for API and data flow
      - E2E testing with Cypress for critical user flows
      - Performance testing with Core Web Vitals monitoring
    - Included testing best practices:
      - Test organization and naming conventions
      - Mocking strategies and test data factories
      - Coverage goals and quality gates
      - Troubleshooting guides and common issues
    - Added testing section to README.md with quick start commands
    - Provided examples for component testing, API testing, hook testing, and E2E testing
    - Documented performance testing thresholds and monitoring procedures
    - Created CI/CD pipeline documentation for automated testing
